package it.polimi.ingsw.client.view;

import it.polimi.ingsw.client.SendMessageToServer;
import it.polimi.ingsw.client.handlers.PlayerHandler;
import it.polimi.ingsw.client.handlers.ProductionPowersHandler;
import it.polimi.ingsw.client.handlers.ResourceMarketHandler;
import it.polimi.ingsw.messages.*;
import it.polimi.ingsw.server.Model.ActionToken;
import it.polimi.ingsw.server.Model.Cards.DevelopmentCard;
import it.polimi.ingsw.server.Model.Cards.LeaderCard;
import it.polimi.ingsw.server.Model.Cards.ProductionPower;
import it.polimi.ingsw.server.Model.Enums.ActionEnum;
import it.polimi.ingsw.server.Model.Enums.MarbleEnum;
import it.polimi.ingsw.server.Model.Enums.ResourceEnum;
import it.polimi.ingsw.server.Model.Enums.TypeLineEnum;
import it.polimi.ingsw.server.Model.FaithTrack.FaithTrack;
import it.polimi.ingsw.server.Model.PersonalBoard.DevelopmentSlots;
import it.polimi.ingsw.server.Model.PersonalBoard.Strongbox;
import it.polimi.ingsw.server.Model.PersonalBoard.Warehouse.Depot;
import it.polimi.ingsw.server.Model.PersonalBoard.Warehouse.Warehouse;
import it.polimi.ingsw.server.Model.Requirements.Requirement;
import it.polimi.ingsw.server.Model.Requirements.ResourceRequirement;
import it.polimi.ingsw.server.Model.Table.CardMarket.CardDeck;
import it.polimi.ingsw.utils.StringUtils;

import java.util.*;

/**
 * CLI implementation of the view part of the MVC pattern.
 * It interacts with the user for every type of event where he's interested, and generates the event messages to be sent to the server.
 *
 * @author Roberto Neglia
 */
public class CLIView implements View {
    private final String DEFAULT_IP_ADDRESS = "127.0.0.1";
    private final int DEFAULT_PORT_NUMBER = 4687;
    private final int MIN_PORT_NUMBER = 1024;
    private final int MAX_PORT_NUMBER = 65535;
    private final int MIN_PLAYER_NUMBER = 1;
    private final int MAX_PLAYER_NUMBER = 4;
    private final int MIN_LEADER_CARD_TO_CHOOSE = 1;
    private final int MAX_LEADER_CARD_TO_CHOOSE = 4;

    private final Scanner kbdScanner;
    private int connectedIndex;
    /**
     * Used to send messages to the server when a new event is generated by the user
     */
    private SendMessageToServer sendToServer;

    public CLIView() {
        kbdScanner = new Scanner(System.in);
    }

    public int getConnectedIndex() {
        return connectedIndex;
    }

    public void setSendToServer(SendMessageToServer sendToServer) {
        this.sendToServer = sendToServer;
    }

    public String askIpAddress() {
        String answer;
        System.out.println("what's the ip address of the server you want to connect to? [DEFAULT: " + DEFAULT_IP_ADDRESS + "]");
        answer = kbdScanner.nextLine();
        if (answer.isEmpty())
            return DEFAULT_IP_ADDRESS;
        else if (StringUtils.isIpAddress(answer))
            return answer;
        else return askIpAddress();
    }

    public int askPortNumber() {
        String answer;
        System.out.println("what's the port number you want to connect to? [DEFAULT: " + DEFAULT_PORT_NUMBER + "]");
        answer = kbdScanner.nextLine();
        if (answer.isEmpty())
            return DEFAULT_PORT_NUMBER;
        else {
            if (StringUtils.isNumeric(answer)) {
                int portNumber = Integer.parseInt(answer);
                if (portNumber < MIN_PORT_NUMBER || portNumber > MAX_PORT_NUMBER) {
                    System.out.println("sorry, but that's an illegal port");
                    return askPortNumber();
                } else
                    return portNumber;
            } else {
                System.out.println("that's not a port number");
                return askPortNumber();
            }
        }
    }

    public boolean askRetry() {
        String answer;
        System.out.println("do you want to try again?");
        answer = kbdScanner.nextLine();
        return answer.equals("yes");
    }

    @Override
    public void askNPlayer() {
        String answer;
        clear();
        System.out.println("how many are playing?");
        answer = kbdScanner.nextLine();
        if (StringUtils.isNumeric(answer)) {
            int nPlayer = Integer.parseInt(answer);
            if (nPlayer < MIN_PLAYER_NUMBER || nPlayer > MAX_PLAYER_NUMBER) {
                System.out.println("there can be only from " + MIN_PLAYER_NUMBER + " to " + MAX_PLAYER_NUMBER + " players");
                askNPlayer();
            } else
                sendToServer.sendNPlayer(nPlayer);
        } else {
            System.out.println("NaN [Not a Number]");
            askNPlayer();
        }
    }

    @Override
    public void askName(AskName e) { // asks the user for a nickname that will be used for the game
        clear();
        String answer;
        if (!e.isAgain()) {
            System.out.println("lobby complete!");
        } else {
            System.out.println("that nickname is already taken, i'm sorry. choose another one");
        }
        do {
            System.out.println("what will your nickname be for this game?");
            answer = kbdScanner.nextLine();
            if (answer.isEmpty() || answer.isBlank())
                System.out.println("that's not a name!");
        } while (answer.isEmpty() || answer.isBlank());
        if (e.getReconnectedPlayerIndex() != -1)
            sendToServer.sendReconnectedName(answer, e.getReconnectedPlayerIndex());
        else sendToServer.sendName(answer);
    }

    public void showWelcome(int connectedIndex) { // shows a welcome message
        this.connectedIndex = connectedIndex;
        clear();
        System.out.println("welcome to\n " +
                "\t\tMaestri del Rinascimento!");
        System.out.println("you're the player number " + (connectedIndex + 1));
    }

    @Override
    public void showFull() {
        System.out.println("server says the lobby is already full, i'm sorry :\\");
        sendToServer.sendCloseConnection();
    }

    @Override
    public void showWait(int connectedPlayers, int totalPlayers) {
        if (connectedPlayers != -1)
            System.out.println("waiting for the lobby to complete... (" + connectedPlayers + "/" + totalPlayers + ")");
        else
            System.out.println("waiting fot the lobby to complete...");
    }

    @Override
    public void waitYourTurn(int playerTurn, String nickname) {
        System.out.println("the player " + nickname + " number " + (playerTurn + 1) + " is starting his turn, please wait that he finishes");
    }

    public void showConnectionClosed() {
        System.out.println("connection correctly closed");
    }

    @Override
    public void chooseLeaderCards(List<LeaderCard> leaderCards) {
        clear();
        System.out.println("you picked the following leader cards");
        int count = 1;
        for (LeaderCard i : leaderCards) {
            System.out.println(" [ " + count + " ] " + i.toString());
            count++;
        }
        System.out.println("you can keep only two of them: which one?");
        int readInt;
        int[] chosen = new int[2];

        count = 0;

        while (count < 2) {
            System.out.println("choose the card number " + (count + 1));
            readInt = readInteger();
            if ((readInt >= MIN_LEADER_CARD_TO_CHOOSE && readInt <= MAX_LEADER_CARD_TO_CHOOSE)) {
                if (count == 0) {
                    chosen[0] = readInt - 1;
                    count++;
                } else if (count == 1 && chosen[count - 1] != readInt - 1) {
                    chosen[1] = readInt - 1;
                    count++;
                } else System.out.println("card number not valid");
            } else System.out.println("card number not valid");
        }

        sendToServer.sendChosenCard(chosen);
    }

    public void askInitialResources(int playerIndex, int nResources, int nFaithPoints, Warehouse warehouse) {
        clear();
        EnumMap<ResourceEnum, Integer> chosenResources = new EnumMap<>(ResourceEnum.class);

        if (nResources == 0) {
            System.out.println("as the first player, you have no initial resources and no initial faith points given");
            promptEnterToContinue();
            sendToServer.sendReady();
        } else {
            System.out.print("since you're the player number " + (playerIndex + 1) + " you have ");
            if (nFaithPoints != 0) {
                System.out.print(nFaithPoints + "initial faith point(s)\n");
            }
            System.out.println("and you have to choose " + nResources + " resource(s), and insert them in your warehouse");

            ResourceEnum[] resourceEnums = Arrays.copyOfRange(ResourceEnum.values(), 0, 4);

            int answer;
            int i = 0;

            while (i < nResources) {
                System.out.println("which resource do you choose?");
                for (int j = 0; j < resourceEnums.length; j++) {
                    System.out.println(" [ " + (j + 1) + " ] " + resourceEnums[j]);
                }
                answer = readInteger();
                if (answer >= 1 && answer <= 4) {
                    ResourceEnum chosenResource = resourceEnums[answer - 1];
                    if (chosenResources.containsKey(chosenResource))
                        chosenResources.replace(chosenResource, chosenResources.get(chosenResource) + 1);
                    else
                        chosenResources.put(chosenResource, 1);
                    i++;
                } else System.out.println("that's not a valid number");
            }
            sendToServer.sendInitialResources(chosenResources);
            askInsertWarehouse(chosenResources, warehouse);
        }
    }

    @Override
    public void askInsertWarehouse(EnumMap<ResourceEnum, Integer> resources, Warehouse warehouse) {
        clear();
        ResourceMarketHandler.setToInsert(resources);
        ResourceEnum[] resourceEnums;
        List<Depot> depots;
        int answer;
        int i;
        boolean retry = true;

        System.out.println("you have to insert some resources in your warehouse");

        while (retry) {
            showWarehouse(warehouse);
            System.out.println("choose the resource you want to insert: ");

            resourceEnums = showNewResources(resources);

            answer = readInteger();

            if (answer >= 1 && answer <= resources.size()) {
                ResourceEnum chosenResource = resourceEnums[answer - 1];
                System.out.println("where do you want to put them?");

                depots = warehouse.getDepots();
                for (i = 0; i < depots.size(); i++) {
                    if (i == 3)
                        System.out.println("leader abilities depots:");
                    System.out.println(" [ " + (i + 1) + " ] " + printDepot(depots.get(i)));
                }
                answer = readInteger();
                if (answer >= 1 && answer <= depots.size()) {
                    int chosenDepotIndex = answer - 1;
                    Depot chosenDepot = depots.get(chosenDepotIndex);
                    ResourceEnum depotResource = chosenDepot.getResource();
                    if (depotResource == ResourceEnum.NONE || depotResource == chosenResource) {
                        sendToServer.sendTryInsert(chosenResource, resources.get(chosenResource), chosenDepotIndex);
                        retry = false;
                    } else {
                        clear();
                        System.out.println("the depot is already occupied by another resource, choose another one, swap it with another one or discard the resource when you insert the others");
                        promptEnterToContinue();
                        retry = false;
                        askHandleNewResourceOrSwap(resources, warehouse);
                        clear();
                    }
                } else {
                    System.out.println("that's not a valid number");
                    promptEnterToContinue();
                    clear();
                }
            } else System.out.println("that's not a valid number");
        }
    }

    @Override
    public void askHandleNewResourceOrSwap(EnumMap<ResourceEnum, Integer> resources, Warehouse warehouse) {
        clear();
        int answer;
        boolean retry = true;
        EnumMap<ResourceEnum, Integer> newResources = new EnumMap<>(ResourceEnum.class);

        if (resources.isEmpty()) {
            System.out.println("all resources have been inserted");
            showWarehouse(warehouse);
            promptEnterToContinue();
            showEndTurnMoves();
        } else {
            if (resources.containsKey(ResourceEnum.NONE)) {
                for (int i = 0; i < resources.get(ResourceEnum.NONE); i++) {
                    boolean retry_switch = true;
                    while (retry_switch) {
                        System.out.println("select the white marble power for the marble n° " + i + 1);
                        System.out.println("[ 1 ] change with : " + playerHandler.getWhiteMarbleLeaderAbility().get(0).toString());
                        System.out.println("[ 2 ] change with : " + playerHandler.getWhiteMarbleLeaderAbility().get(1).toString());

                        int answer_switch = readInteger();
                        if (answer_switch >= 1 && answer_switch <= 2) {
                            ResourceEnum newResource;
                            switch (answer_switch) {
                                case 1:
                                    newResource = playerHandler.getWhiteMarbleLeaderAbility().get(0);
                                    if (newResources.containsKey(newResource)) {
                                        newResources.replace(newResource, newResources.get(newResource) + 1);
                                    } else {
                                        newResources.put(newResource, 1);
                                    }

                                    if (resources.containsKey(newResource)) {
                                        resources.replace(newResource, resources.get(newResource) + 1);
                                    } else resources.put(newResource, 1);


                                    retry_switch = false;
                                    break;
                                case 2:
                                    newResource = playerHandler.getWhiteMarbleLeaderAbility().get(1);
                                    if (newResources.containsKey(newResource)) {
                                        newResources.replace(newResource, newResources.get(newResource) + 1);
                                    } else {
                                        newResources.put(newResource, 1);
                                    }

                                    if (resources.containsKey(newResource)) {
                                        resources.replace(newResource, resources.get(newResource) + 1);
                                    } else resources.put(newResource, 1);

                                    retry_switch = false;
                                    break;
                            }
                        } else {
                            System.out.println("that's not a valid number");
                        }
                    }

                }
                resources.remove(ResourceEnum.NONE);
            }
            ResourceMarketHandler.setToInsert(resources);
            sendToServer.sendWhiteMarbleSelection(newResources);

            System.out.println("You have to manage your new resources");
            showWarehouse(warehouse);
            System.out.println("here's your new resources to manage:");
            showNewResources(resources);
            int maxIndexChoose;

            while (retry) {

                System.out.println("Which action you wanna do?");
                System.out.println("[ 1 ] Insert the new resources");
                if (warehouse.isEmpty()) {
                    maxIndexChoose = 2;
                    System.out.println("[ 2 ] Discard all new resources -> all player will obtain a faith point for any of you discarded resources ");
                } else {
                    maxIndexChoose = 3;
                    System.out.println("[ 2 ] Swap depots");
                    System.out.println("[ 3 ] Discard all remaining resources -> all player will obtain a faith point for any of you discarded resources ");
                }

                answer = readInteger();
                if (answer >= 1 && answer <= maxIndexChoose) {
                    retry = false;
                    switch (answer) {
                        case 1:
                            askInsertWarehouse(resources, warehouse);
                            break;
                        case 2:
                            if (warehouse.isEmpty()) {
                                discardRemainingResources(resources);
                            } else {
                                askSwapDepots(resources, warehouse);
                            }
                            break;
                        case 3:
                            discardRemainingResources(resources);
                            break;
                    }
                } else System.out.println("that's not a valid number");
            }
        }

    }

    @Override
    public void askSwapDepots(EnumMap<ResourceEnum, Integer> resources, Warehouse warehouse) {
        clear();
        int idxDepot1;
        int idxDepot2;
        boolean retry = true;


        System.out.println("Which depots do you wanna change?");
        System.out.println("[ 0 ] Return to the main menu");
        do {
            showWarehouse(warehouse);
            System.out.println("Please select the first depot");
            idxDepot1 = readInteger();

            if (idxDepot1 == 0) {
                askHandleNewResourceOrSwap(resources, warehouse);

            }

            System.out.println("Please select the second depot");
            idxDepot2 = readInteger();
            if (idxDepot2 == 0) {
                askHandleNewResourceOrSwap(resources, warehouse);
                retry = false;
            }

            if (idxDepot1 != idxDepot2 && idxDepot1 >= 1 && idxDepot1 <= warehouse.getDepots().size() && idxDepot2 >= 1 && idxDepot2 <= warehouse.getDepots().size()) {
                retry = false;
            } else {
                System.out.println("Please indicate the corrects indexes of depots");
            }
        } while (retry);

        sendToServer.sendSwapDepotsRequest(idxDepot1, idxDepot2);
    }

    @Override
    public void elaborateSwapResult(String result, boolean success, Warehouse warehouse) {
        clear();
        System.out.println("Swap depot action result: \n" + result);
        promptEnterToContinue();
        if (success) {
            askHandleNewResourceOrSwap(ResourceMarketHandler.getToInsert(), warehouse);
        } else {
            askSwapDepots(ResourceMarketHandler.getToInsert(), warehouse);
        }
    }

    public void showWarehouse(Warehouse warehouse) {
        System.out.println("here's your updated warehouse");
        int i = 1;
        for (Depot d : warehouse.getDepots()) {
            if (i == 4) {
                System.out.println("leader abilities depots:");
            }
            System.out.println(" [ " + i + " ] " + printDepot(d));
            i++;
        }
    }

    public ResourceEnum[] showNewResources(EnumMap<ResourceEnum, Integer> newResources) {
        ResourceEnum[] resourceEnums = new ResourceEnum[newResources.size()];

        int i = 1;
        for (Map.Entry<ResourceEnum, Integer> entry : newResources.entrySet()) {
            System.out.println(" [ " + i + " ] " + entry.getKey() + " | " + entry.getValue());
            resourceEnums[i - 1] = entry.getKey();
            i++;
        }
        return resourceEnums;
    }

    public void confirmDiscard(TryInsert m) {
        System.out.println("you will discard " + m.getToDiscard() + " " + m.getResource() + "(s) and consequently give " + m.getToDiscard() + " faith point(s) to all the other players");
        System.out.println("ok? [ yes / no ]");
        String answer = kbdScanner.nextLine();
        if (answer.equals("yes"))
            sendToServer.confirmInsert(m.getResource(), m.getQuantity() - m.getToDiscard(), m.getChosenDepot());
        else sendToServer.abortInsert();
    }

    public void showTurnMoves() {
        clear();
        System.out.println("-------------- your turn starts --------------");
        boolean retry = true;

        while (retry) {
            System.out.println("what do you want to do in this turn?");
            System.out.println(" [ 1 ] go to the resource market");
            System.out.println(" [ 2 ] go to the card market");
            System.out.println(" [ 3 ] use a production power");
            System.out.println(" [ 4 ] activate a leader card");
            System.out.println(" [ 5 ] discard a leader card");

            int answer = readInteger();
            if (answer >= 1 && answer <= 5) {
                retry = false;
                switch (answer) {
                    case 1:
                        sendToServer.sendResourceMarketRequest();
                        break;
                    case 2:
                        sendToServer.sendCardMarketRequest();
                        break;
                    case 3:
                        sendToServer.sendProductionPowerRequest();
                        break;
                    case 4:
                        sendToServer.sendObtainLeaderCard(false, true);
                        break;
                    case 5:
                        sendToServer.sendObtainLeaderCard(true, true);
                        break;
                }

            } else {
                System.out.println("not a valid move");
            }
        }

    }

    public void showEndTurnMoves() {
        clear();
        boolean retry = true;

        while (retry) {
            System.out.println("which move you want to perform before ending your turn?");
            System.out.println(" [ 1 ] activate a leader card");
            System.out.println(" [ 2 ] discard a leader card");
            System.out.println(" [ 3 ] finally end your turn");

            int answer = readInteger();
            if (answer >= 1 && answer <= 3) {
                retry = false;
                switch (answer) {
                    case 1:
                        sendToServer.sendObtainLeaderCard(false, false);
                        break;
                    case 2:
                        sendToServer.sendObtainLeaderCard(true, false);
                        break;
                    case 3:
                        sendToServer.endTurn();
                        break;
                }

            } else {
                System.out.println("not a valid move");
            }
        }
    }

    @Override
    public void selectLeaderCardToDiscard(GetLeaderCard m) {

        boolean retry = true;


        while (retry) {
            boolean isAnyLeaderCardAvailable = (m.getAvailableLeaderCard().size() > 0);
            System.out.println("[ " + 0 + " ] go back to the action menu");
            if (isAnyLeaderCardAvailable) {
                System.out.println("select the leader card to discard:");
                for (int i = 0; i < m.getAvailableLeaderCard().size(); i++) {
                    System.out.println("[ " + (i + 1) + " ] " + m.getAvailableLeaderCard().get(i).toString());
                }
            } else {
                System.out.println("there are no leader cards to discard");
            }


            int answer = readInteger();

            if (answer >= 0 && answer <= m.getAvailableLeaderCard().size()) {
                retry = false;
                switch (answer) {
                    case 0:
                        if (m.isStartTurn()) {
                            showTurnMoves();
                        } else {
                            showEndTurnMoves();
                        }
                        break;
                    case 1:
                    case 2:
                        sendToServer.sendDiscardLeaderCard(m.isDiscardAction(), m.isStartTurn(), m.getAvailableLeaderCard().get(answer - 1));
                        break;
                }
            } else {
                System.out.println("not a valid move");
            }

        }
    }

    @Override
    public void selectLeaderCardToActivate(GetLeaderCard m) {
        boolean retry = true;

        while (retry) {
            boolean isAnyLeaderCardAvailable = (m.getAvailableLeaderCard().size() > 0);
            System.out.println("[ " + 0 + " ] go back to action menu");
            if (isAnyLeaderCardAvailable) {
                System.out.println("select the leader card to activate:");
                for (int i = 0; i < m.getAvailableLeaderCard().size(); i++) {
                    System.out.println("[ " + (i + 1) + " ] " + m.getAvailableLeaderCard().get(i).toString());
                }
            } else {
                System.out.println("there are no leader cards to be activated");
            }


            int answer = readInteger();

            if (answer >= 0 && answer <= m.getAvailableLeaderCard().size()) {
                retry = false;
                switch (answer) {
                    case 0:
                        if (m.isStartTurn()) {
                            showTurnMoves();
                        } else {
                            showEndTurnMoves();
                        }
                        break;
                    case 1:
                    case 2:
                        sendToServer.sendActivateLeaderCard(m.isDiscardAction(), m.isStartTurn(), m.getAvailableLeaderCard().get(answer - 1));
                        break;
                }
            } else {
                System.out.println("not a valid move");
            }
        }
    }

    @Override
    public void showStatusDiscardLeaderCard(DiscardLeaderCard m) {
        clear();
        if (m.getSucccessDiscard()) {
            System.out.println("leader card correctly discarded, you obtained a faith point");
        } else System.out.println("impossible to discard this leader card");
        promptEnterToContinue();
        if (m.getIsStartTurn()) {
            showTurnMoves();
        } else {
            showEndTurnMoves();
        }
    }

    @Override
    public void showStatusActivateLeaderCard(ActivateLeaderCard m) {
        clear();
        if (m.getSuccessActivate()) {
            System.out.println("leader card correctly activated, from now on you can use its special effect");
            playerHandler.setDiscountLeaderAbility(m.getDiscountLeaderCardAbilities());
            playerHandler.setWhiteMarbleLeaderAbility(m.getWhiteMarbleLeaderCardAbilities());
        } else System.out.println("impossible to activate this leader card");
        promptEnterToContinue();
        if (m.getIsStartTurn()) {
            showTurnMoves();
        } else {
            showEndTurnMoves();
        }
    }

    private String printDepot(Depot depot) {
        String printableDepot = "";
        int i;
        for (i = 0; i < depot.getAmountStored(); i++) {
            printableDepot = printableDepot.concat(depot.getResource().toString() + " ");
        }
        while (i < depot.getSize()) {
            printableDepot = printableDepot.concat("empty ");
            i++;
        }
        return printableDepot;
    }

    private int readInteger() {
        String read = kbdScanner.nextLine();
        if (StringUtils.isNumeric(read))
            return Integer.parseInt(read);
        return -1;
    }


    @Override
    public void showCardMarketStructure(CardDeck[][] cardMarketStructure, Warehouse playerWarehouse, Strongbox playerStrongbox) {
        clear();
        System.out.println("Card Market Structure:");
        CliWriteTable wrT = new CliWriteTable();
        String[] tableHeader = new String[]{" // ", " [1->GREEN] ", " [2->PURPLE] ", " [3->BLUE] ", " [4->YELLOW] "};
        wrT.setTableHead(tableHeader);
        for (int i = 0; i < cardMarketStructure.length; i++) {
            String[] tableRow = new String[cardMarketStructure[i].length + 1];
            String indexCell = " [" + (i + 1) + "] ";
            tableRow[0] = indexCell;
            for (int j = 0; j < cardMarketStructure[i].length; j++) {
                if (cardMarketStructure[i][j].getSize() > 0) {
                    tableRow[j + 1] = cardMarketStructure[i][j].peek().toString();
                } else {
                    tableRow[j + 1] = "Empty Deck";
                }
            }
            wrT.addRow(tableRow);
        }
        wrT.print();
        showWarehouse(playerWarehouse);
        showStrongbox(playerStrongbox);
        promptEnterToContinue();
        showNewCardsManagementRequest();
    }

    @Override
    public void showNewCardsManagementRequest() {
        boolean retry = true;
        int colorSelected = -1, levelSelected = -1;

        while (retry) {
            System.out.println("Please select a color between GREEN[1], PURPLE[2], BLUE[3], YELLOW[4] (0 to go back to the main menu)?");
            colorSelected = readInteger();
            if (colorSelected >= 1 && colorSelected <= 4) {
                retry = false;
            } else if (colorSelected == 0) {
                showTurnMoves();
                return;
            } else System.out.println("not a valid number, please retry");
        }
        colorSelected--;
        retry = true;

        while (retry) {
            System.out.println("Please select a level between [1], [2], [3] (0 to go back to the main menu)?");
            levelSelected = readInteger();
            if (levelSelected >= 1 && levelSelected <= 3) {
                retry = false;
            } else if (levelSelected == 0) {
                showTurnMoves();
                return;
            } else System.out.println("not a valid number, please retry");
        }
        levelSelected--;
        sendToServer.sendSelectedCardFromMarket(levelSelected, colorSelected);
    }


    @Override
    public void showResourceMarketStructure(MarbleEnum[][] resourceMarketStructure) {
        clear();
        System.out.println("Resource Market Structure:");
        CliWriteTable wrT = new CliWriteTable();
        String[] tableHeader = new String[]{" // ", " [1] ", " [2] ", " [3] ", " [4] "};
        wrT.setTableHead(tableHeader);
        for (int i = 0; i < resourceMarketStructure.length; i++) {
            String[] tableRow = new String[resourceMarketStructure[i].length + 1];
            String indexCell = " [" + (i + 1) + "] ";
            tableRow[0] = indexCell;
            for (int j = 0; j < resourceMarketStructure[i].length; j++) {
                if (resourceMarketStructure[i][j].equals(MarbleEnum.BLUE)) {
                    tableRow[j + 1] = " [Shield] ";

                }
                if (resourceMarketStructure[i][j].equals(MarbleEnum.PURPLE)) {
                    tableRow[j + 1] = " [Servant] ";

                }
                if (resourceMarketStructure[i][j].equals(MarbleEnum.GRAY)) {
                    tableRow[j + 1] = " [Stone] ";

                }
                if (resourceMarketStructure[i][j].equals(MarbleEnum.RED)) {
                    tableRow[j + 1] = " [Faith] ";

                }
                if (resourceMarketStructure[i][j].equals(MarbleEnum.YELLOW)) {
                    tableRow[j + 1] = " [Coin] ";

                }
                if (resourceMarketStructure[i][j].equals(MarbleEnum.WHITE)) {
                    tableRow[j + 1] = " [-] ";

                }
//                switch (resourceMarketStructure[i][j]) {
//                    case BLUE:
//                    case PURPLE:
//                    case GRAY:
//                    case RED:
//                    case WHITE:
//                    case YELLOW:
//                }
            }
            wrT.addRow(tableRow);
        }
        wrT.print();

        promptEnterToContinue();
        showNewResourcesManagementRequest();

    }

    @Override
    public void showNewResourcesManagementRequest() {
        System.out.println("Do you want to select a row [1] or column [2]? ([0] to go back to main menu)");
        int typeSelected = readInteger();
        TypeLineEnum typeLine;

        switch (typeSelected) {
            case 0:
                showTurnMoves();
                break;
            case 1:
                typeLine = TypeLineEnum.ROW;
                System.out.println("Please write the row index: (from 1 to 3)");
                int selectedRow = readInteger();
                if (selectedRow >= 1 && selectedRow <= 3) {
                    sendToServer.sendSelectedResourceFromMarket(typeLine, selectedRow - 1);
                } else {
                    System.out.println("Command not valid");
                    showNewResourcesManagementRequest();
                }
                break;
            case 2:
                typeLine = TypeLineEnum.COL;
                System.out.println("Please write the column index: (from 1 to 4) ([0] to go back to main menu)");
                int selectedColumn = readInteger();
                if (selectedColumn >= 1 && selectedColumn <= 4) {
                    sendToServer.sendSelectedResourceFromMarket(typeLine, selectedColumn - 1);
                } else if (selectedColumn == 0)
                    showTurnMoves();
                else {
                    System.out.println("Command not valid");
                    showNewResourcesManagementRequest();
                }
                break;
            default:
                System.out.println("Command not valid");
                showNewResourcesManagementRequest();
        }


    }

    public void showWaitSetup(int readyPlayers, int total) {
        if (readyPlayers != -1)
            System.out.println(readyPlayers + "/" + total + " are ready, please wait");
        else
            System.out.println("wait for other players to end their setup please");
    }

    @Override
    public void showProductionPowers(List<ProductionPower> playerProductionPowers) {
        boolean retry;
        retry = true;

        while (retry) {
            System.out.println("you can choose between these production powers to use...");
            if (!PlayerHandler.isAlreadyProductionActivated()) {
                System.out.println("[ 0 ] Turn back to the main menu");
            }

            int i = 1;
            for (ProductionPower pp : playerProductionPowers) {
                System.out.println(" [ " + i + " ] " + pp);
                i++;
            }

            if (PlayerHandler.isAlreadyProductionActivated()) {
                System.out.println(" [ " + i + " ] to finish using production abilities and finish your turn");
            }

            int answer = readInteger();

            if (answer == 0) {
                retry = false;
                if (!PlayerHandler.isAlreadyProductionActivated()) {
                    showTurnMoves();
                }
            } else if (answer > 0 && answer <= playerProductionPowers.size()) {
                retry = false;
                sendToServer.sendTryUseProductionPower(playerProductionPowers.get(answer - 1));
                ProductionPowersHandler.setCurrentProductionPower(playerProductionPowers.get(answer - 1));
            } else if (answer == playerProductionPowers.size() + 1) {
                if (PlayerHandler.isAlreadyProductionActivated()) {
                    retry = false;
                    sendToServer.insertObtainedResources();
                }
            } else System.out.println("that's not a valid number, please retry");
        }
    }

    public void askPayLocation(ChooseResourceLocation m) {
        ResourceRequirement resourceSelected;
        int i, answer, selectedQuantityToPay;
        int inWarehouse;
        int inStrongbox;
        EnumMap<ResourceEnum, Integer> payWarehouse = new EnumMap<>(ResourceEnum.class);
        EnumMap<ResourceEnum, Integer> payStrongbox = new EnumMap<>(ResourceEnum.class);
        List<ResourceRequirement> toPay = new ArrayList<>(Arrays.asList(m.getToPay()));
        Warehouse playerWarehouse = m.getPlayerWarehouse();
        Strongbox playerStrongbox = m.getPlayerStrongbox();


        while (toPay.size() != 0) {
            System.out.println("choose a resource to pay");

            i = 1;
            for (ResourceRequirement r : toPay) {
                System.out.println(" [ " + i + " ] " + r.getResourceType() + " - " + r.getQuantity());
                i++;
            }

            answer = readInteger();
            if (answer > 0 && answer <= toPay.size()) {

                showWarehouse(playerWarehouse);
                showStrongbox(playerStrongbox);

                resourceSelected = toPay.get(answer - 1);
                selectedQuantityToPay = resourceSelected.getQuantity();

                if (resourceSelected.getResourceType() == ResourceEnum.JOLLY) {
                    handleJollyResource(toPay, resourceSelected, playerWarehouse, payWarehouse, playerStrongbox, payStrongbox);
                } else {
                    while (selectedQuantityToPay > 0) {
                        ResourceRequirement updatedResourceSelected = new ResourceRequirement(resourceSelected.getResourceType(), selectedQuantityToPay);

                        inWarehouse = playerWarehouse.getResourceAmount(resourceSelected.getResourceType());
                        inStrongbox = playerStrongbox.getResourceCount(resourceSelected.getResourceType());

                        if (inWarehouse != 0 && inStrongbox != 0) {
                            System.out.println("choose where to take " + updatedResourceSelected.getQuantity() + " " + resourceSelected.getResourceType() + "(s)");
                            System.out.println(" [ 1 ] to take it from the warehouse");
                            System.out.println(" [ 2 ] to take it from the strongbox");

                            answer = readInteger();
                            if (answer == 1) {
                                selectedQuantityToPay -= chooseFromWarehouse(updatedResourceSelected, playerWarehouse, payWarehouse);
                            } else if (answer == 2) {
                                selectedQuantityToPay -= chooseFromStrongbox(updatedResourceSelected, playerStrongbox, payStrongbox);
                            }

                        } else if (inWarehouse != 0) {
                            System.out.println("you have the resource selected only in your warehouse, i will take it from there");
                            selectedQuantityToPay -= chooseFromWarehouse(updatedResourceSelected, playerWarehouse, payWarehouse);
                        } else if (inStrongbox != 0) {
                            System.out.println("you have the resource selected only in your strongbox, i will take it from there");
                            selectedQuantityToPay -= chooseFromStrongbox(updatedResourceSelected, playerStrongbox, payStrongbox);
                        }
                    }
                }
                toPay.remove(resourceSelected);
            } else System.out.println("not a valid number, retry");
        }
        System.out.println("all resources have been paid");
        sendToServer.sendChosenResourceLocation(new ChooseResourceLocation(payWarehouse, payStrongbox));
    }

    private void handleJollyResource(List<ResourceRequirement> toPay, ResourceRequirement selectedResource, Warehouse playerWarehouse, EnumMap<ResourceEnum, Integer> payWarehouse, Strongbox playerStrongbox, EnumMap<ResourceEnum, Integer> payStrongbox) {
        ResourceEnum[] resources = Arrays.copyOfRange(ResourceEnum.values(), 0, 4);
        ResourceEnum chosenResource;
        List<ResourceEnum> availableResourcesWarehouse = new ArrayList<>();
        List<ResourceEnum> availableResourcesStrongbox = new ArrayList<>();
        int i, answer;
        int qty;
        int qtyToPay = selectedResource.getQuantity();

        System.out.println("you selected a jolly resource, hence you can use any resource");

        while (qtyToPay > 0) {
            System.out.println("choose a resource to use: ");

            System.out.println("\t from the warehouse...");
            i = 1;
            for (ResourceEnum r : resources) {
                qty = playerWarehouse.getResourceAmount(r);
                if (qty >= qtyToPay) {
                    System.out.println(" [ " + i + " ] " + r + " - " + qty);
                    availableResourcesWarehouse.add(r);
                    i++;
                }
            }
            if (availableResourcesWarehouse.size() == 0) {
                System.out.println("you don't have any in your warehouse");
            }
            System.out.println("\t from the strongbox...");
            for (ResourceEnum r : resources) {
                qty = playerStrongbox.getResourceCount(r);
                if (qty >= qtyToPay) {
                    System.out.println(" [ " + i + " ] " + r + " - " + qty);
                    availableResourcesStrongbox.add(r);
                    i++;
                }
            }
            if (availableResourcesStrongbox.size() == 0) {
                System.out.println("you don't have any in your strongbox");
            }

            answer = readInteger();
            if (answer > 0 && answer <= i) {
                if (answer <= availableResourcesWarehouse.size()) {
                    chosenResource = availableResourcesWarehouse.get(answer - 1);
                    qtyToPay -= chooseFromWarehouse(new ResourceRequirement(chosenResource, qtyToPay), playerWarehouse, payWarehouse);
                } else {
                    chosenResource = availableResourcesStrongbox.get(answer - availableResourcesWarehouse.size() - 1);
                    qtyToPay -= chooseFromStrongbox(new ResourceRequirement(chosenResource, qtyToPay), playerStrongbox, payStrongbox);
                }
            }
        }
    }

    private int chooseFromWarehouse(ResourceRequirement resourceSelected, Warehouse playerWarehouse, EnumMap<ResourceEnum, Integer> payWarehouse) {
        int inWarehouse = playerWarehouse.getResourceAmount(resourceSelected.getResourceType());
        int quantityRemovedFromWarehouse = 0;
        int answer;
        boolean retry = true;
        while (retry) {
            System.out.println("how many? (you have " + inWarehouse + ", you need to pay " + resourceSelected.getQuantity() + ")");
            answer = readInteger();
            if(answer >= 0) {
                if (answer <= inWarehouse) {
                    if (answer <= resourceSelected.getQuantity()) {
                        playerWarehouse.remove(resourceSelected.getResourceType(), answer);
                        if (payWarehouse.containsKey(resourceSelected.getResourceType()))
                            payWarehouse.put(resourceSelected.getResourceType(), payWarehouse.get(resourceSelected.getResourceType()) + answer);
                        else payWarehouse.put(resourceSelected.getResourceType(), answer);
                        quantityRemovedFromWarehouse += answer;
                        retry = false;
                    } else System.out.println("you are paying more than it needs, retry");
                } else System.out.println("you don't have that much in your warehouse, retry");
            }
        }
        return quantityRemovedFromWarehouse;
    }

    private int chooseFromStrongbox(ResourceRequirement resourceSelected, Strongbox playerStrongbox, EnumMap<ResourceEnum, Integer> payStrongbox) {
        int inStrongbox = playerStrongbox.getResourceCount(resourceSelected.getResourceType());
        int quantityRemovedFromStrongbox = 0;
        int answer;
        boolean retry = true;
        while (retry) {
            System.out.println("how many? (you have " + inStrongbox + ", you need to pay " + resourceSelected.getQuantity() + ")");
            answer = readInteger();
            if(answer >= 0) {
                if (answer <= inStrongbox) {
                    if (answer <= resourceSelected.getQuantity()) {
                        playerStrongbox.remove(resourceSelected.getResourceType(), answer);
                        if (payStrongbox.containsKey(resourceSelected.getResourceType()))
                            payStrongbox.put(resourceSelected.getResourceType(), payStrongbox.get(resourceSelected.getResourceType()) + answer);
                        else payStrongbox.put(resourceSelected.getResourceType(), answer);
                        quantityRemovedFromStrongbox += answer;
                        retry = false;
                    } else System.out.println("you are paying more than it needs, retry");
                } else System.out.println("you don't have that much in your strongbox, retry");
            }
        }
        return quantityRemovedFromStrongbox;
    }

    public void showStrongbox(Strongbox strongbox) {
        System.out.println("here's your updated strongbox");
        ResourceEnum[] strongboxResources = Arrays.copyOfRange(ResourceEnum.values(), 0, 4);

        for (ResourceEnum strongboxResource : strongboxResources) {
            System.out.println("\t" + strongboxResource + " - " + strongbox.getResourceCount(strongboxResource));
        }
    }

    public void showObtainedResources(EnumMap<ResourceEnum, Integer> obtainedResources) {
        System.out.println("you successfully used the production power and obtained the following resources:");
        System.out.println(obtainedResources);
    }

    @Override
    public void askJollyResources(EnumMap<ResourceEnum, Integer> obtainedResources, boolean isBaseProductionPower) {
        int toChoose = obtainedResources.get(ResourceEnum.JOLLY);
        System.out.println("you can choose " + toChoose + " resource(s)");
        System.out.println("which one do you choose?");

        int minResValue = 0;
        int maxResValue = isBaseProductionPower ? 4 : 5;

        ResourceEnum[] resources = Arrays.copyOfRange(ResourceEnum.values(), minResValue, maxResValue);
        int i;
        int answer;

        while (toChoose > 0) {
            i = 1;
            for (ResourceEnum r : resources) {
                System.out.println(" [ " + i + " ] " + r);
                i++;
            }

            answer = readInteger();

            if (answer > 0 && answer <= resources.length) {
                ResourceEnum chosenResource = resources[answer - 1];
                System.out.println("you choose to take " + chosenResource);
                sendToServer.sendJollyResource(chosenResource, toChoose);
                obtainedResources.remove(ResourceEnum.JOLLY);
                if (obtainedResources.containsKey(chosenResource))
                    obtainedResources.put(chosenResource, obtainedResources.get(chosenResource) + toChoose);
                else obtainedResources.put(chosenResource, toChoose);
                toChoose = 0;
            }
        }
    }

    public void emptyDeck() {
        clear();
        System.out.println("You tried to buy a card from a deck that is empty.");
        promptEnterToContinue();
    }

    @Override
    public void showWrongDepot() {
        clear();
        System.out.println("there is a depot with that resource in it, choose another one please");
        promptEnterToContinue();
    }


    public void notEnoughResources(List<Requirement> requirements, ActionEnum action) {
        clear();
        switch (action) {
            case PRODUCTION_POWER:
                System.out.println("you can't use the production power, cause you're missing the following requirements:");
                for (Requirement r : requirements) {
                    System.out.println("\t" + r);
                }
                promptEnterToContinue();
                showProductionPowers(ProductionPowersHandler.getProductionPowers());
                break;
            case BUY_CARD:
                System.out.println("you can't buy this development card, cause you're missing the following requirements:");
                if(!requirements.isEmpty())
                {
                    for (Requirement r : requirements) {
                        System.out.println("\t" + r);
                    }
                }else{
                    System.out.println("The level is too high for your slots");
                }

                promptEnterToContinue();
                break;
            case LEADER_ACTIVATION:
                System.out.println("you can't activate this leader card, cause you're missing the following requirements:");
                for (Requirement r : requirements) {
                    System.out.println("\t" + r);
                }
                promptEnterToContinue();
                break;
        }


    }

    public void notEnoughResourcesActivateLeaderCard(List<Requirement> requirements, Boolean isStartTurn) {
        clear();
        System.out.println("you can't activate this leader card, cause you're missing the following requirements:");
        for (Requirement r : requirements) {
            System.out.println("\t" + r);
        }
        promptEnterToContinue();
        if (isStartTurn) {
            showTurnMoves();
        } else {
            showEndTurnMoves();
        }
    }

    private void discardRemainingResources(EnumMap<ResourceEnum, Integer> newResourcesToDiscard) {
        sendToServer.sendDiscardResources(newResourcesToDiscard);
    }

    public void showBoughtCard(DevelopmentCard card) {
        clear();
        System.out.println("Here's the card you have just bought :");
        System.out.println(card.toString());
        promptEnterToContinue();
    }

    public void showDevSlots(DevelopmentSlots slots) {
        clear();
        System.out.println("Here's your development slots :");
        for (int i = 0; i < DevelopmentSlots.getMaxSize(); i++) {
            DevelopmentCard cardTmp = slots.getSlot(i).peekLast();
            String tmpString = cardTmp != null ? cardTmp.toString() : "empty";
            System.out.println("\t[" + (i + 1) + "] - " + tmpString);
        }
        promptEnterToContinue();
    }

    public void askSlotToInsert(DevelopmentSlots slots, DevelopmentCard boughtCard) {
        int slotSelected;
        boolean retry = true;

        while (retry) {
            showDevSlots(slots);
            System.out.println("Choose a slot where to insert the card you just bought [1], [2], [3] ?");
            slotSelected = readInteger();

            if (slotSelected >= 1 && slotSelected <= 3) {
                retry = false;
                slotSelected--;
                sendToServer.sendSelectedSlotToInsertCard(slotSelected);
            } else System.out.println("not a valid number, please retry");
        }
    }

    @Override
    public void showInvalidInsertion(String errorMessage) {
        System.out.println(errorMessage);
    }


    @Override
    public void showGameOver(GameOver m) {
        if (m.isWinner()) {
            System.out.println("CONGRATULATIONS, YOU WON THE GAME!!");
            System.out.println("you obtained " + m.getWinnerPlayer().getTotalVictoryPoints() + " victory points!");
        } else if (m.getWinnerPlayer() == null) {
            System.out.println("i'm sorry, but " + "Lorenzo il Magnifico" + " has won the game :(");
            System.out.println(m.getTerminator());
        } else {
            System.out.println("i'm sorry, but " + m.getWinnerPlayerNickname() + " has won the game :(");
            System.out.println("you obtained " + m.getYourFaithPoints() + " victory points");
        }
    }

    public void showFaithTrack(FaithTrack updatedFaithTrack, boolean lorenzo) {
        clear();
        if (lorenzo) {
            System.out.println("here's Lorenzo's updated faith track");
            System.out.println("legend:");
            System.out.println("✞: Lorenzo current position in the faith track");
        } else {
            System.out.println("here's your updated faith track");
            System.out.println("legend:");
            System.out.println("✝: your current position in the faith track");
        }
        System.out.println("Ÿ: pope space, activates the vatican report in that section");
        System.out.println("¥: last cell, acts like a pope space for the last section, but also ends the game");
        System.out.println("C, T, O (for vatican report sections): C -> Covered, T -> Thrown, O -> Obtained");
        System.out.println("a cell with a number in it is a cell that gives you that number of victory points when reached");
        System.out.println(updatedFaithTrack);
        promptEnterToContinue();
    }

    public void showTotalVictoryPoints(int victoryPoints) {
        System.out.println("you achieved " + victoryPoints + " in this game");
    }

    @Override
    public void showLorenzoActionToken(ActionToken lorenzoToken) {
        clear();
        System.out.println("Lorenzo picked the following action: ");
        System.out.println(lorenzoToken);
        promptEnterToContinue();
    }


    private void promptEnterToContinue() {
        System.out.println("press \"ENTER\" to continue...");
        kbdScanner.nextLine();
    }

    public void clear() {
        for (int i = 0; i < 100; i++) {
            System.out.println();
        }
    }

}
