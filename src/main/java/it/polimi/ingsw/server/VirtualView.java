package it.polimi.ingsw.server;

import it.polimi.ingsw.messages.*;
import it.polimi.ingsw.server.Controller.Controller;
import it.polimi.ingsw.server.Controller.GamePhase;
import it.polimi.ingsw.server.Controller.MultiPlayerController;
import it.polimi.ingsw.server.Controller.SinglePlayerController;
import it.polimi.ingsw.server.Model.Game;
import it.polimi.ingsw.server.Model.Player;

import java.util.HashMap;
import java.util.List;
import java.util.Objects;

/**
 * Class that represents the remote implementation of the view part of the MVC pattern.
 * It behaves as a normal view from the perspective of the events created by the clients and the notifications to the client when updates in the model takes place.
 * It observes the Model, so it will updates the actual view on the client side by sending messages to him using the SendMessageToClient class.
 * It is also observed by the Controller, so when a new event comes from the client side View, it notifies the controller to update the information.
 *
 * @author Roberto Neglia
 */
public class VirtualView {

    /**
     * Used to send messages to the client when a new event takes place. See more {@link SendMessageToClient}
     */
    private final SendMessageToClient sendToClient;

    /**
     * The reference to the controller of the MVC pattern: it observes the (virtual) view.
     */
    private Controller controller;

    /**
     * The reference to the Model of the MVC pattern: it's observed by the (virtual) view.
     */
    private Game game;

    /**
     * Class constructor
     *
     * @param sendToClient SendMessageToClient {@link SendMessageToClient}
     */
    public VirtualView(SendMessageToClient sendToClient) {
        this.sendToClient = sendToClient;
        game = null;
    }

    /**
     * Method that handles a new player connection event: creates initial messages to set up the game
     *
     * @param waitingPlayerIndex index of the client inside the waiting list
     */
    public void newPlayer(int waitingPlayerIndex) {
        if (game == null) // if the game is not yet instantiated
            sendToClient.sendToFirst(); // flow of messages for the first player
        else
            sendToClient.sendToOther(waitingPlayerIndex, controller.getNPlayers()); // otherwise flow of messages for all the other players
    }

    public void setGame(Game game) {
        this.game = game;
    }

    /**
     * Notify the controller that a new event arrived from the client
     *
     * @param e the event generated by the client
     */
    public void notifyObserver(Message e) {
        controller.update(e);
    }

    public void nameAlreadyTaken(int connectedPlayerIndex) {
        sendToClient.askName(connectedPlayerIndex, true);
    }

    /**
     * Notify the controller that the first player has sent the number of players
     *
     * @param e the event generated by the client
     */
    public void notifyObserver(AskNPlayer e) {
        if (e.getNPlayer() > 1) {
            controller = new MultiPlayerController(this, e.getNPlayer());
            sendToClient.sendWait();
        } else {
            controller = new SinglePlayerController(this);
            sendToClient.askName();
        }
    }

    /**
     * Notify the controller that a player has sent his name
     *
     * @param e the event generated by the client
     */
    public void notifyObserver(AskName e) {
        Server server = sendToClient.getServer();
        HashMap<String, Integer> nicknameSolver = server.getConnectedNicknameSolver();

        if (nicknameSolver.containsKey(e.getPlayerName())  && sendToClient.isLobbyCompleteOnce()) {
            if (game.getPlayers().get(nicknameSolver.get(e.getPlayerName())).isConnected())
                sendToClient.sendAlreadyFull(e.getSender(), false);
            else {
                server.adjustConnectedIndex(e.getPlayerName(), e.getReconnectedPlayerIndex());

                int reconnectedPlayerPosition = server.getConnectedNicknameSolver().get(e.getPlayerName());
                Player reconnectedPlayer = game.getPlayers().get(reconnectedPlayerPosition);
                reconnectedPlayer.setConnected(true);
                if (reconnectedPlayer.getGamePhase() == GamePhase.CHOOSE_LEADER_CARD)
                    update(reconnectedPlayerPosition, new ChooseLeaderCard(reconnectedPlayer.getLeaderCardsToChoose()));
                else if (reconnectedPlayer.getGamePhase() == GamePhase.CHOOSE_INITIAL_RESOURCES)
                    controller.update(new ReconnectInitialResources(reconnectedPlayerPosition));
                else if (reconnectedPlayer.getGamePhase() == GamePhase.GAME) {
                    if (!controller.isSetup()) {
                        int currentPlayerIndex = game.getPlayers().indexOf(game.getCurrentPlayer());

                        if(onlyOneConnected()) {
                            if (reconnectedPlayerPosition != currentPlayerIndex) {
                                game.nextPlayer();
                            }
                            update(reconnectedPlayerPosition, new TurnStartEvent(reconnectedPlayerPosition, reconnectedPlayer.getNickname()));
                        } else update(reconnectedPlayerPosition, new WaitTurnEvent(game.getPlayers().indexOf(game.getCurrentPlayer()), game.getCurrentPlayer().getNickname()));

//                        if (reconnectedPlayerPosition == currentPlayerIndex)
//                            update(reconnectedPlayerPosition, new TurnStartEvent(reconnectedPlayerPosition, reconnectedPlayer.getNickname()));
//                        else if(onlyOneConnected()){
//                            game.nextPlayer();
//                            update(reconnectedPlayerPosition, new TurnStartEvent(reconnectedPlayerPosition, reconnectedPlayer.getNickname()));
//                        }
//                        else
//                            update(reconnectedPlayerPosition, new WaitTurnEvent(game.getPlayers().indexOf(game.getCurrentPlayer()), game.getCurrentPlayer().getNickname()));
                    } else
                        update(reconnectedPlayerPosition, new SetupComplete());
                }
            }
        } else {

            int nPlayersDisconnected = game.getPlayers().stream().noneMatch(Objects::nonNull) ? 0 :  (int) game.getPlayers().stream().filter(p -> p != null && !p.isConnected()).count();

            //mi serve togliere l'insieme intersezione dei due insiemi NicknameSolver e ConnectedClients
            int alreadyConnectedPlayersInNicknameSolver = server.getConnectedClients().size() - nicknameSolver.size();

            boolean checkerFull = ( server.getConnectedClients().size() + nPlayersDisconnected) > controller.getNPlayers();

            if (nicknameSolver.size() == controller.getNPlayers() || checkerFull) {
                sendToClient.sendAlreadyFull(e.getSender(), false);
                server.getConnectedClients().get(e.getSender()).close();
                sendToClient.setNullInConnected(e.getSender());
            } else {
                controller.update(e);
                server.setConnectedNickname(e.getPlayerName(), e.getSender());
            }
        }
    }

    private boolean onlyOneConnected() {
        List<Player> currentPlayers = game.getPlayers();
        int count = 0;
        for (Player currentPlayer : currentPlayers) {
            if (currentPlayer.isConnected()) {
                count++;
            }
        }
        return count == 1;
    }

    public void notifyObserver(ChooseLeaderCard m) {
        controller.update(m);
    }

    public void notifyObserver(ChooseInitialResources m) {
        controller.update(m);
    }

    public void notifyObserver(TryInsert m) {
        controller.update(m);
    }

    public void notifyObserver(ConfirmInsert m) {
        controller.update(m);
    }

    public void notifyObserver(PlayerReady m) {
        controller.update(m);
    }

    public void notifyObserver(SwapDepot e) { // new event from the client view, the first player sent the number of players
        controller.update(e); // updates the controller
    }

    public void notifyObserver(ResourceMarketAction m) {
        controller.update(m);
    }

    public void notifyObserver(CardMarketAction m) {
        controller.update(m);
    }

    public void notifyObserver(SlotInsertionAction m) {
        controller.update(m);
    }

    public void notifyObserver(SelectedCardFromMarket m) {
        controller.update(m);
    }

    public void notifyObserver(SelectedResourceFromMarket m) {
        controller.update(m);
    }

    public void notifyObserver(DiscardResources m) {
        controller.update(m);
    }

    public void notifyObserver(GetLeaderCard m) {
        controller.update(m);
    }

    public void notifyObserver(DiscardLeaderCard m) {
        controller.update(m);
    }

    public void notifyObserver(ActivateLeaderCard m) {
        controller.update(m);
    }

    public void notifyObserver(ProductionPowerAction m) {
        controller.update(m);
    }

    public void notifyObserver(UseProductionPower m) {
        controller.update(m);
    }

    public void notifyObserver(ChooseResourceLocation m) {
        controller.update(m);
    }

    public void notifyObserver(EndTurn m) {
        controller.update(m);
    }

    public void notifyObserver(AbortInsert m) {
        controller.update(m);
    }

    public void notifyObserver(ProductionPowerUsed m) {
        controller.update(m);
    }

    public void notifyObserver(InsertJollyResource m) {
        controller.update(m);
    }

    public void notifyObserver(WhiteMarbleSelection m) {
        controller.update(m);
    }

    public void handleDisconnectedPlayer(int playerIndex) {
        List<Player> players = game.getPlayers();
        Player disconnectedPlayer = players.get(playerIndex);
        if (disconnectedPlayer == null) {
            sendToClient.decrementAskingName();
            boolean afterMe = false;
            for (int i = playerIndex + 1; i < players.size(); i++) {
                if (players.get(i) != null) {
                    afterMe = true;
                    break;
                }
            }

            if (afterMe) {
                sendToClient.setNullInConnected(playerIndex);
            } else sendToClient.completelyRemoveFromConnected(playerIndex);
        } else {
            disconnectedPlayer.setConnected(false);
            sendToClient.setNullInConnected(playerIndex);
            if (controller.isSetup())
                controller.update(new WaitSetup());
            else {
                if (disconnectedPlayer.getNickname().equals(game.getCurrentPlayer().getNickname()))
                    controller.continueGameAfterDisconnection();
            }
        }
    }

    public void update(int playerIndex, Message updateMsg) {
        if (game.getPlayers().get(playerIndex).isConnected())
            sendToClient.sendMessage(playerIndex, updateMsg);
    }

    public void update(Message m) {
        sendToClient.sendBroadcastMessage(m);
    }

    public void update(RunGame e) {
        controller.runGame();
    }

    public void update(EndGame e) {
        controller.endGame();
    }
}
